#  Copyright 2019 MongoDB Inc.
#
#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  "License"); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing,
#  software distributed under the License is distributed on an
#  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#  KIND, either express or implied.  See the License for the
#  specific language governing permissions and limitations
#  under the License.

import os
import pathlib
import webbrowser

import requests

from invoke import task

from serverworkflowtool import config
from serverworkflowtool.config import DownloadConfig
from serverworkflowtool.templates import evergreen_yaml_template
from serverworkflowtool.utils import get_logger, instruction, log_func, log_err_res


def evergreen_yaml(conf):
    # initialize Jira to get the jira user name for Evergreen.
    if config.EVG_CONFIG_FILE.exists():
        get_logger().info(
            'Found existing ~/.evergreen.yml, skipping adding Evergreen configuration')
        get_logger().info(
            'Please ensure your ~/.evergreen.yml was generated by this tool. If not, '
            'make sure you know what\'s in there')
    else:
        settings_url = 'https://evergreen.mongodb.com/login/key'
        while True:
            res = requests.post(settings_url, json={'username': conf.username, 'password': conf.jira_pwd})
            if res.status_code != 200:
                get_logger().error('Failed to fetch API key from evergreen. Error: %s', str(res))
                input(instruction('Press any key to retry...'))
                continue
            res_json = res.json()

            evg_config = evergreen_yaml_template.format(res_json['user'], res_json['api_key'])

            with open(config.EVG_CONFIG_FILE, 'w') as fh:
                fh.write(evg_config)
            break

    return True


def ssh_keys():
    if config.SSH_KEY_FILE.is_file():
        get_logger().info('Found existing key ~/.ssh/id_rsa, skipping setting up ssh keys')
        get_logger().info('Please ensure your keys are added to your GitHub account')
        return True

    res = input(instruction('Opening browser for instructions to setting up ssh keys in GitHub, '
                            'press any key to continue, enter "skip" to skip: '))
    if res != 'skip':
        webbrowser.open(config.GITHUB_SSH_HELP_URL)
        input(
            'Once you\'ve generated SSH keys and added them to GitHub, press any key to continue')
    else:
        get_logger().info('Skipping adding SSH Keys to GitHub')

    while not (config.SSH_KEY_FILE.is_file()):
        get_logger().error(
            str(config.SSH_KEY_FILE) + ' is not a file, please double check you have completed '
                                       'GitHub\'s guide on setting up SSH keys')

    return True


def clone_repos(ctx):
    repo_parent_dir = config.HOME / 'mongodb'
    repo_parent_dir.mkdir(exist_ok=True)
    get_logger().info('Placing MongoDB Git repositories in %s', repo_parent_dir)

    res_ok = True

    with ctx.cd(str(repo_parent_dir)):
        for repo_config in config.REQUIRED_REPOS:
            repo_dir = repo_parent_dir / repo_config.relative_local
            if repo_dir.exists():
                get_logger().warning(
                    'Local directory %s exists. If you\'d like to re-clone,'
                    'please delete this directory first', str(repo_dir))
            else:
                cmd = f'git clone {repo_config.remote} {repo_dir}'
                get_logger().info(cmd)
                res = ctx.run(cmd, hide=False)
                log_err_res(res)

                res_ok = res and res_ok

    return res_ok


def create_dir(ctx, conf, dir_absolute):
    d = pathlib.Path(dir_absolute)
    if d.exists() and d.owner() == config.USER:
        get_logger().warning(f'Directory {d} exists and is owned by the current user, skipping creating it')
        return True

    # Need Invoke for sudo. Can't use native Python mkdir().
    res1 = ctx.sudo(f'mkdir -p {d}', warn=False, password=conf.get_sudo_pwd(ctx))
    res2 = ctx.sudo(f'chown {config.USER} {d}', warn=False, password=conf.get_sudo_pwd(ctx))

    if res1 and res2:
        get_logger().info(f'Created directory {d}')
        return True
    else:
        log_err_res(res1)
        log_err_res(res2)
        return False


def _do_download(ctx, download_config):
    with ctx.cd(str(config.HOME)):
        local_path = config.HOME / download_config.relative_local
        if local_path.exists():
            get_logger().warning('Local file %s exists. If you\'d like to re-download this '
                                 'file, please delete the local copy first.', local_path)
            return True
        else:
            cmd = f'curl -o {download_config.relative_local} {download_config.remote}'
            get_logger().info(cmd)
            res = ctx.run(cmd)
            log_err_res(res)
            return res.ok


def download_clang_format(ctx):
    bin_dir = config.HOME / 'bin'

    if (bin_dir / 'clang-format').exists():
        get_logger().warning('File %s already exists. Skipping installing clang-format',
                             str(bin_dir / 'clang-format'))
        return True

    dc = DownloadConfig(
        'https://s3.amazonaws.com/boxes.10gen.com/build/clang%2Bllvm-3.8.0-x86_64-apple-darwin.tar.xz',
        relative_local='bin/llvm3.8.0.tar.xz'
    )

    _do_download(ctx, dc)

    with ctx.cd(str(bin_dir)):
        ugly_name = 'clang+llvm-3.8.0-x86_64-apple-darwin'
        pretty_name = 'llvm-3.8.0'

        if not (bin_dir / pretty_name).exists():
            res1 = ctx.run('tar -xvzf llvm3.8.0.tar.xz')
            log_err_res(res1)

            res2 = ctx.run(f'mv {ugly_name} {pretty_name}')
            log_err_res(res2)
        else:
            get_logger().warning('Directory %s exists. Skipping extracting llvm', str(bin_dir / pretty_name))

        # softlink clang-format to a convenient location.
        res3 = ctx.run(f'ln -s {str(bin_dir / pretty_name / "bin" / "clang-format")} clang-format')
        log_err_res(res3)
        return res3.ok


def download_evergreen(ctx):
    pass


@task
def macos(ctx):
    conf = config.Config()

    funcs = [
        # Do tasks that require user interaction first.
        (lambda: ssh_keys(), 'Configure SSH Keys'),
        (lambda: create_dir(ctx, conf, '/data'), 'Create MongoDB Data Directory'),
        (lambda: create_dir(ctx, conf, '/opt/mongodbtoolchain'), 'Create MongoDB Toolchain Directory'),
        (lambda: create_dir(ctx, conf, str(config.HOME / 'bin')), 'Create User bin Directory'),

        # Then do the automated tasks that don't require user interaction.
        (lambda: evergreen_yaml(conf), 'Configure Evergeen'),
        (lambda: clone_repos(ctx), 'Clone MongoDB Repositories'),
        (lambda: download_clang_format(ctx), 'Download clang-format'),
        (lambda: download_evergreen(ctx), 'Download evergreen CLI')

        # githooks
        # toolchain
        # evg binary
        # clang format
        # copy profile to .config/server-workflow-tool
    ]

    for func in funcs:
        success = log_func(func[0], func[1])
